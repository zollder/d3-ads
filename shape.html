<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Experiments with D3 shapes</title>
		<!-- <script type="text/javascript" src="libs/require.js"></script> -->
		<script type="text/javascript" src="libs/rbtree.min.js"></script>
		<script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>
		<style type="text/css">
			h1 {
				text-align: center;
				font-size: 20px;
			}
			svg {
				stroke-width: 3px;
				border: 1px solid grey;
			}
			.xAxis path, .xAxis line,
			.yAxis path, .yAxis line {
				fill: none;
				stroke: grey;
				stroke-width: 1;
				shape-rendering: crispEdges;
			}
			path.line {
				stroke: steelblue;
				stroke-width: 2;
				fill: steelblue;
				fill-opacity: 0.3;
			}
			path.xCursor {
				stroke: grey;
				stroke-width: 1;
			}
			circle {
				fill: blue;
			}
			path {
				stroke: steelblue;
				stroke-width: 2px;
				stroke-linecap: round;
			}
		</style>
	</head>
	<body>
	    <div id="graph">
			<h1>Line Sweep algorithm visualization</h1>
		</div>
		<div id="toolbox">
				<input id="undoBtn" name="updateButton"  type="button" value="Undo" onclick="removeLast()" />
				<input id="clearBtn" name="clearButton"  type="button" value="Clear" onclick="clearAll()" />
				<input id="sweepBtn" name="sweepButton"  type="button" value="Sweep" onclick="sweep()" />
		</div>
		<script type="text/javascript" charset="utf-8">

			var width = 600;
			var height = 400;

			var currentPath;
			var isDrawing = false;
			var lines = [];
			var intersections = [];

			/*
				Initializes main components and behavior.
			*/
			var svg = d3.select("body")
				.append("svg")
					.attr("width", width)
					.attr("height", height)
					.on("mousedown", onMouseDown)
					.on("mouseup", onMouseUp);

			/*
				Line function definition.
			*/
			var lineFunct = d3.line()
				.x(function (d) {
					return d[0];
				})
				.y(function (d) {
					return d[1];
				});

			/*
				OnMouseDown event handler.
				Captures mouse coordinates for the line's start point.
				Appends the line and its end point.
			*/
			function onMouseDown() {
				isDrawing = true;
				var startPos = d3.mouse(this);

				// set line's start point
				lines.push([startPos, [0, 0]]);
				console.log("start: ", startPos);

				// draw the line
				var line = lineFunct([startPos, startPos]);
				currentPath = svg.append("path").attr("d", line);

				// draw line's start point
				svg.append("circle")
					.data([startPos])
					.attr("r", 3)
					.attr("cx", function(d) {return d[0]; })
					.attr("cy", function(d) {return d[1]; });

				// pass arguments to onMouseMove
				svg.data([startPos])
					.on("mousemove", onMouseMove);
			}

			/*
				OnMouseMove event handler.
				Captures current mouse coordinates to visualize live drawing.
			*/
			function onMouseMove(startPos) {
				var currentPos = d3.mouse(this);
				if (isDrawing) {
					var line = lineFunct([startPos, currentPos]);
					currentPath.attr("d", line);
				}
			}

			/*
				OnMouseUp event handler.
				Captures mouse coordinates for the end of line being drawn.
				Updates and appends line's end point.
			*/
			function onMouseUp() {
				isDrawing = false;
				var startPos = lines[lines.length - 1][0];
				var endPos = d3.mouse(this);

				// update line's end points
				if (startPos[0] < endPos[0]) {
					lines[lines.length - 1][1] = endPos;
				} else {
					lines[lines.length - 1][0] = endPos;
					lines[lines.length - 1][1] = startPos;
				}

				// draw line's end point
				svg.append("circle")
					.data([endPos])
					.attr("r", 3)
					.attr("cx", function(d) {return d[0]; })
					.attr("cy", function(d) {return d[1]; });
				console.log("lines: ", lines.toString());
			}

			/*
				Removes the last line and associated terminal points
				1. associate data to selection
				2. retrieve and remove the diff
			*/
			function removeLast() {
				console.log("Removed line: ", lines.pop());
				svg.selectAll("path").data(lines).exit().remove();
				svg.selectAll("circle").data(getPoints(lines)).exit().remove();
			}

			/*
				Cleans the drawing area.
				Removes all lines and associated terminal points.
			*/
			function clearAll() {
				console.log("Clearing ...")
				svg.selectAll("path").remove();
				svg.selectAll("circle").remove();
			}

			/*
				Sweeps the cursor through data all points.
				Smoothly translates the line by x pixels b/w points.
			*/
			function sweep() {
				var linesMap = initLineMap(lines);

			/* 1. Init intersection point holder. */
				var intersections = new Set();

			/* 2. Init an empty active set that holds segments currently crossed by the sweep line. */

				// contains segments cut by SL and sorted by Y (left point)
				var active = new RBTree(function(a, b) {
					return a.left.y - b.left.y;
				});
				console.log("Active: ", active);

			/* 3. Init a priority queue (BST) and fill it with all segment's end-points sorted by X coordinate. */

				// segment's end-points and intersection points sorted by X (unique key)
				var events = initEventsTree(linesMap);

				// initialize the cursor
				var xCursor = svg.append("path")
					.attr("d", lineFunct([[0, 0], [0, height]]))
					.attr('class', 'xCursor');

				// loop through all events/points
				var id = setInterval(frame, 1000);
				function frame() {
					var point = events.min();
					events.remove(point);

					var segment = linesMap.get(point.lineId);
					if (isLeft(point)) {
						console.log("Insert segment: ", segment);
						active.insert(segment);

						// check upper & lower neighbors for intersections
						checkForNeighborIntersections(segment, events, active, intersections);
						console.log("Intersections: ", intersections);
					} else if (isRight(point)) {
						console.log("Remove segment: ", segment);
						checkForNeighborIntersections(segment, events, active, intersections);
						active.remove(segment);
					} else {} // intersection point - sweep silently, do nothing
					console.log("Active: ", active);

					// sweep cursor line to the current point
					xCursor.transition().duration(1000)
						.attr("transform", function(){
							return "translate(" + point.x + ",0)";
						});

					if (events.size == 0) {
						clearInterval(id);
					}
				}
				// ------------------------------------------------------------------------------------
				/*
					0. Init intersection point holder.
					1. Init an empty active set that holds segments currently crossed by the sweep line 
					2. Init a priority queue (BST) and fill it with all segment's end-points sorted by X coordinate
					3. While the BST is not empty, process each end-point:
						3.1 Retrieve the point with min X coordinate
						3.2 If it's a "left" endpoint
							- insert the line the point belongs to into an active set sorted by left point's Y coordinate
							- check neighbors, if any, for intersections
							- ??? insert discovered intersection, if any, into the priority queue (BST)
							- insert discovered intersection, if any, into the ordered set of intersections
						3.3 If it's a "right" point
							- remove the line the point belongs to from the active set
							- check neighbors, if any, for intersections
							- insert discovered intersections, into "found" set 
				*/


				return intersections;
			}

			// build key-value map of lines
			function initLineMap(lines) {
				var map = new Map();
				lines.forEach(function(line, indx) {
					map.set(indx, { id:indx, left:{ x:line[0][0], y:line[0][1] }, right:{ x:line[1][0], y:line[1][1] } });
				});
				console.log("Lines Map: ", map);
				return map;
			}

			/*
				Initilizes and returns an events/points tree data structure.
				Creates a new RB tree with events comparator.
				Inserts end points of known line segments into the tree.
				Points are sorted by X (key) coordinate.
			*/
			function initEventsTree(linesMap) {
				var events = new RBTree(function(a, b) { return a.x - b.x; });
				linesMap.forEach(function(value, key) {
					events.insert({ type:"left", x:value.left.x, y:value.left.y, lineId:key });
					events.insert({ type:"right", x:value.right.x, y:value.right.y, lineId:key });
				});
				console.log("Events: ", events);
				return events;
			}

			// check upper & lower neighbors for intersections
			function checkForNeighborIntersections(segment, events, active, intersections) {
				var iter, prev, next, ixPoint;
				iter = active.findIter(segment);
				if (iter && iter.prev()) {
					ixPoint = getIntersectionPoint(segment, iter.data());
					if (ixPoint) {
						events.insert(ixPoint);
						intersections.add(ixPoint);
						drawIntersectionPoint(ixPoint);
					}
				}
				iter = active.findIter(segment);
				if (iter && iter.next()) {
					ixPoint = getIntersectionPoint(segment, iter.data());
					if (ixPoint) {
						events.insert(ixPoint);
						intersections.add(ixPoint);
						drawIntersectionPoint(ixPoint);
					}
				}
			}

			/*
				Intersection check.
				Returns an intersection point if lines intersect, or empty point otherwise.
			*/
			function getIntersectionPoint(segment1, segment2) {
				/*
					Derive coefficients for each line equation (ax + by = c),
					where a = y2 - y1, b = x1 - x2
				*/
				var x1 = segment1.left.x;
				var x2 = segment1.right.x;
				var y1 = segment1.left.y;
				var y2 = segment1.right.y;
				var a1 = y2 - y1;
				var b1 = x1 - x2;
				var c1 = a1*x1 + b1*y1;

				var x3 = segment2.left.x;
				var x4 = segment2.right.x;
				var y3 = segment2.left.y;
				var y4 = segment2.right.y;
				var a2 = y4 - y3;
				var b2 = x3 - x4;
				var c2 = a2*x3 + b2*y3;

				/*
					Find intersection point (x,y) by solving the system of linear equations
					using inverse matrix method:
					A*X = B => X = Ainv*B, where Ainv = [coeff. matrix]/det
					|a1 b1| * |x| = |c1| -> |x| =  1  * | b2 -b1| * |c1|
					|a2 b2|   |y|   |c2|    |y|   det   |-a2  a1|   |c2|
				*/
				var det = a1*b2 - a2*b1;
				if (det === 0) {	// lines are parallel
					console.log("Determinant = 0");
					return null;
				}

				// line intersection coordinates
				var x = (b2*c1 - b1*c2) / det;
				var y = (a1*c2 - a2*c1) / det;
				console.log("Global intersection {x:", x, " y:", y, "} ids [", segment1.id, ",", segment2.id);

				/* Segments intersect if (x,y) is within the segment's range */
				var inRange = x > min(x1, x2) && x < max(x3, x4) && y > min(y1, y2) && y < max(y3, y4);
				if (inRange) {
					console.log("In range intersection {x:", x, " y:", y, "}");
					return { type:"intersection", x:x, y:y, lineId:segment1.id };
				}

				console.log("Not in range");
				return null;
			}

			/*
				Returns an array of terminal points for given lines.
			*/
			function getPoints(lines) {
				var points = [];
				for (var i = 0; i < lines.length; i++) {
					for (var j = 0; j < lines[i].length; j++) {
						points.push(lines[i][j]);
					}
				}
				return points;
			}

			/*
				Maps lines to segment objects.
				Returns a collection of segments.
			*/
			function getSegments(lines) {
				return lines.map(function(val, indx) {
					return {
						id:  indx,
						left: { id: indx, type: "left", point: val[0] },
						right: { id: indx, type: "right", point: val[1] }
					};
				});
			}

			/*
				Maps lines to point objects.
				Sorts points in ascending order by x coordinate.
				Returns a collection of sorted segment points.
			*/
			function getSegmentPoints(lines) {
				var points = [];
				lines.forEach(function(val, idx) {
					points.push({ id: idx, type: "left", x: val[0][0], y: val[0][1] });
					points.push({ id: idx, type: "right", x: val[1][0], y: val[1][1] });
				});
				points.sort(function(a, b) {
					return a.x - b.x;
				});
				return points;
			}

			// draw discovered intersection point, if any
			function drawIntersectionPoint(point) {
				if (point) {
					svg.append("circle")
						.data([point])
						.style("fill",'red')
						.attr("r", 3)
						.attr("cx", function(d) {return d.x; })
						.attr("cy", function(d) {return d.y; });
				}
			}

			function isLeft(point) {
				return point.type === "left";
			}

			function isRight(point) {
				return point.type === "right";
			}

			function isIntersection(point) {
				return point.type === "intersection";
			}

			function max(val1, val2) {
				return val1 > val2 ? val1 : val2;
			}

			function min(val1, val2) {
				return val1 < val2 ? val1 : val2;
			}

		</script>
	</body>
</html>