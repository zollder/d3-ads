<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Experiments with D3 shapes</title>
		<!-- <script type="text/javascript" src="libs/require.js"></script> -->
		<script type="text/javascript" src="libs/rbtree.min.js"></script>
		<script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>
		<style type="text/css">
			h1 {
				text-align: center;
				font-size: 20px;
			}
			svg {
				stroke-width: 3px;
				border: 1px solid grey;
			}
			.xAxis path, .xAxis line,
			.yAxis path, .yAxis line {
				fill: none;
				stroke: grey;
				stroke-width: 1;
				shape-rendering: crispEdges;
			}
			path.line {
				stroke: steelblue;
				stroke-width: 2;
				fill: steelblue;
				fill-opacity: 0.3;
			}
			path.xCursor {
				stroke: grey;
				stroke-width: 1;
			}
			circle {
				fill: blue;
			}
			path {
				stroke: steelblue;
				stroke-width: 2px;
				stroke-linecap: round;
			}
		</style>
	</head>
	<body>
	    <div id="graph">
			<h1>Line Sweep algorithm visualization</h1>
		</div>
		<div id="toolbox">
				<input id="undoBtn" name="updateButton"  type="button" value="Undo" onclick="removeLast()" />
				<input id="clearBtn" name="clearButton"  type="button" value="Clear" onclick="clearAll()" />
				<input id="sweepBtn" name="sweepButton"  type="button" value="Sweep" onclick="sweep()" />
		</div>
		<script type="text/javascript" charset="utf-8">

		/* TODO:
			1. convert lines array of arrays to an array of objects to be able to add labels and so other useful manipulations
			2. round inersection point values and show its coordinates
			3. 
		*/

			var width = 600;
			var height = 400;

			var currentPath;
			var isDrawing = false;
			var lines = [];
			var intersections = [];

			/*
				Initializes main components and behavior.
			*/
			var svg = d3.select("body")
				.append("svg")
					.attr("width", width)
					.attr("height", height)
					.on("mousedown", onMouseDown)
					.on("mouseup", onMouseUp);

			/*
				Line function definition.
			*/
			var lineFunct = d3.line()
				.x(function (d) {
					return d[0];
				})
				.y(function (d) {
					return d[1];
				});

			/*
				OnMouseDown event handler.
				Captures mouse coordinates for the line's start point.
				Appends the line and its end point.
			*/
			function onMouseDown() {
				isDrawing = true;
				var startPos = d3.mouse(this);

				// set line's start point
				lines.push([startPos, [0, 0]]);
				console.log("start: ", startPos);

				// draw the line
				var line = lineFunct([startPos, startPos]);
				currentPath = svg.append("path").attr("d", line);

				// draw line's start point
				svg.append("circle")
					.data([startPos])
					.attr("r", 3)
					.attr("cx", function(d) {return d[0]; })
					.attr("cy", function(d) {return d[1]; });

				// pass arguments to onMouseMove
				svg.data([startPos])
					.on("mousemove", onMouseMove);
			}

			/*
				OnMouseMove event handler.
				Captures current mouse coordinates to visualize live drawing.
			*/
			function onMouseMove(startPos) {
				var currentPos = d3.mouse(this);
				if (isDrawing) {
					var line = lineFunct([startPos, currentPos]);
					currentPath.attr("d", line);
				}
			}

			/*
				OnMouseUp event handler.
				Captures mouse coordinates for the end of line being drawn.
				Updates and appends line's end point.
			*/
			function onMouseUp() {
				isDrawing = false;
				var startPos = lines[lines.length - 1][0];
				var endPos = d3.mouse(this);

				// update line's end points
				if (startPos[0] < endPos[0]) {
					lines[lines.length - 1][1] = endPos;
				} else {
					lines[lines.length - 1][0] = endPos;
					lines[lines.length - 1][1] = startPos;
				}

				// draw line's end point
				svg.append("circle")
					.data([endPos])
					.attr("r", 3)
					.attr("cx", function(d) {return d[0]; })
					.attr("cy", function(d) {return d[1]; });
				console.log("lines: ", lines.toString());
			}

			/*
				Removes the last line and associated terminal points
				1. associate data to selection
				2. retrieve and remove the diff
			*/
			function removeLast() {
				console.log("Removed line: ", lines.pop());
				svg.selectAll("path").data(lines).exit().remove();
				svg.selectAll("circle").data(getPoints(lines)).exit().remove();
			}

			/*
				Cleans the drawing area.
				Removes all lines and associated terminal points.
			*/
			function clearAll() {
				console.log("Clearing ...")
				svg.selectAll("path").remove();
				svg.selectAll("circle").remove();
			}

			// ------------------------------------------------------------------------------------
			/*
				0. Init intersection point holder.
				1. Init an empty active set that holds segments currently crossed by the sweep line 
				2. Init a priority queue (BST) and fill it with all segment's end-points sorted by X coordinate
				3. While the BST is not empty, process each end-point:
					3.1 Retrieve the point with min X coordinate
					3.2 If it's a "left" endpoint
						- insert the line the point belongs to into an active set sorted by left point's Y coordinate
						- check neighbors, if any, for intersections
						- ??? insert discovered intersection, if any, into the priority queue (BST)
						- insert discovered intersection, if any, into the ordered set of intersections
					3.3 If it's a "right" point
						- remove the line the point belongs to from the active set
						- check neighbors, if any, for intersections
						- insert discovered intersections, into "found" set 
			*/

			// TODO: define Point object and use it in EventPoint and Segment
			var EventPoint = function EventPoint (type, id, x, y) {
				this.type = type;
				this.lineId = id;
				this.x = x;
				this.y = y;
				this.ids = null;
			};
			EventPoint.prototype = {
				constructor: EventPoint,

				isLeft: function() {
					return this.type === "left";
				},

				isRight: function() {
					return this.type === "right";
				},

				isIntersection: function() {
					return this.type === "intersection" && this.ids != null;
				},

				/*
				 Verifies if the point is in range of the segment.
				 Returns true if the point lies within segment's projections, or false otherwise.
				 */
				inRange: function(left, right) {
					if (!left || !right)
						return false;

					return this.x >= this.min(left.x, right.x)
						&& this.y >= this.min(left.y, right.y)
						&& this.x <= this.max(left.x, right.x)
						&& this.y <= this.max(left.y, right.y);
				},

				/* Draws intersection point (itself) */
				drawIntersection: function() {
					if (this.isIntersection()) {
						svg.append("circle")
								.data([this])
								.style("fill",'red')
								.attr("r", 3)
								.attr("cx", function(d) { return d.x; })
								.attr("cy", function(d) { return d.y; });
					} else {
						console.log("Not an intersection point", this);
					}
					return this;
				},

				/* Draws specified point, TODO: find a better place/use-case (segment?) */
				drawPoint: function(point) {
					svg.append("circle")
						.data([point])
						.style("fill",'green')
						.attr("r", 3)
						.attr("cx", function(d) { return d.x; })
						.attr("cy", function(d) { return d.y; });
					return this;
				},

				drawLabel: function() {
					svg.append("text")
							.data([this])
							.attr("x", function(d) { return d.x; })
							.attr("y", function(d) { return d.y; })
							.attr("dx", "-10")
							.attr("dy", "-5")
							.text(function(d) { return d.lineId; });
				},

				min: function(val1, val2) {
					return val1 < val2 ? val1 : val2;
				},

				max: function(val1, val2) {
					return val1 > val2 ? val1 : val2;
				}
			};
				
			var Segment = function Segment (id, left, right) {
				this.id = id;
				this.ref = left;
				this.left = left;
				this.right = right;
			};
			Segment.prototype = {
				constructor: Segment,

				setRef: function(refPoint) {
					this.ref = refPoint;
					return this;
				},

				updateRefByX : function(xRef) {
					var x1 = this.left.x;
					var x2 = this.right.x;
					var y1 = this.left.y;
					var y2 = this.right.y;
					var A = y2 - y1;
					var B = x1 - x2;
					var C = A*x1 + B*y1;
					// Ax + By = C => y = (C - Ax) / B
					var yRef = (C - A*xRef)/B;
					return this.setRef({x:xRef, y:yRef});
				},

				updateRefByY: function(yRef) {
					var x1 = this.left.x;
					var x2 = this.right.x;
					var y1 = this.left.y;
					var y2 = this.right.y;
					var A = y2 - y1;
					var B = x1 - x2;
					var C = A*x1 + B*y1;
					// Ax + By = C => x = (C - By) / A
					var xRef = (C - B*yRef)/A;
					return this.setRef({x:xRef, y:yRef});
				}
			};

			var SweepLine = {
				tree: null,

				init: function() {
					console.log("Initializing SL tree");
					this.tree = new RBTree(function(a, b) {
						return a.ref.y - b.ref.y;
					});
					return this;
				},

				insert: function(segment) {
					if (!this.tree) {
						this.init();
					}
					if (!this.tree.insert(segment)) {
						console.log("Segment exists:", segment.id);
					}
					return this;
				},

				insertAndReorder: function(segment) {
					return this.insert(segment).reorder(segment.ref.x);
				},

				remove: function(segment) {
					if (!this.tree) {
						console.log("SL tree is not initialized");
					}
					if (!this.tree.remove(segment)) {
						console.log("Segment doesn't exists:", segment.id);
					}
					return this;
				},

				reorder: function(xRef) {
					var sl = this;
					this.getNodes().forEach(function(node) {
						sl.remove(node).insert(node.updateRefByX(xRef));
					});
					return this;
				},

				next: function(segment) {
					if (!this.tree || !segment) {
						return null;
					}
					var iterator = this.tree.findIter(segment);
					if (iterator && iterator.next()) {
						return iterator.data();
					}
					return null;
				},

				previous: function(segment) {
					if (!this.tree || !segment) {
						return null;
					}
					var iterator = this.tree.findIter(segment);
					if (iterator && iterator.prev()) {
						return iterator.data();
					}
					return null;
				},

				getNodes: function () {
					var nodes = [];
					if (!this.tree) {
						return nodes;
					}
					this.tree.each(function(node) {
						nodes.push(node);
					});
					return nodes;
				},

				print: function() {
					if (!this.tree) {
						console.log("SL tree is not initialized");
						return;
					}
					var printSet = [];
					this.tree.each(function(segment) {
						printSet.push(segment.id);
					});
					console.log("SL tree: ", printSet);
				},

				swap: function(seg1, seg2) {
					this.print();
					console.log("SL swapping: ", seg1.id, seg2.id);
					if (this.tree.remove(seg1) && this.tree.remove(seg2)) {
						var yRefSeg1 = seg1.ref.y;
						var yRefSeg2 = seg2.ref.y;
						this.insert(seg1.updateRefByY(yRefSeg2));
						this.insert(seg2.updateRefByY(yRefSeg1));
					}
					this.print();
					return this;
				}
			};

			/*
				Sweeps the cursor through data all points.
				Smoothly translates the line by x pixels b/w points.
			*/
			function sweep() {
				var linesMap = initLineMap(lines);
				var intersections = new Set();

				// contains segments cut by SL and sorted by Y (left point)
				var active = SweepLine.init();

				// segment's end-points and intersection points sorted by X (unique key)
				var events = initEventsTree(linesMap);

				// initialize the cursor
				var xCursor = svg.append("path")
					.attr("d", lineFunct([[0, 0], [0, height]]))
					.attr('class', 'xCursor');

				// loop through all events/points with 1s interval
				var intervalId = setInterval(frame, 1000);
				function frame() {
					var point = events.min();
					var segment = linesMap.get(point.lineId);
					console.log("Event", point.lineId, "[", point.x, ",", point.y, "]");

					if (point.isLeft()) {
						console.log("SL inserting: ", segment.id);
						point.drawLabel();
						active.insertAndReorder(segment);
						active.print();

						var ixUpperPoint = getIntersectionPoint(segment, active.previous(segment));
						if (ixUpperPoint) {
							console.log("Add intersection event: ", ixUpperPoint);
							events.insert(ixUpperPoint);
						}
						var ixLowerPoint = getIntersectionPoint(segment, active.next(segment));
						if (ixLowerPoint) {
							console.log("Add intersection event: ", ixLowerPoint);
							events.insert(ixLowerPoint);
						}
						var ixPoint = getIntersectionPoint(active.next(segment), active.previous(segment));
						if (ixPoint) {
							console.log("Remove intersection event: ", ixPoint);
							events.remove(ixPoint);
						}
					}
					else if (point.isRight()) {
						active.print();

						var ixPoint = getIntersectionPoint(active.previous(segment), active.next(segment));
						if (ixPoint) {
							console.log("Add intersection event: ", ixPoint);
							events.insert(ixPoint);
						}
						console.log("SL removing: ", segment.id);
						active.remove(segment);
					}
					else {	// intersection point
						// add this point to intersections set/list
						console.log("Processing intersection point:", point);
						var ixPointAsString = JSON.stringify({ x:point.x, y:point.y });
						if (!intersections.has(ixPointAsString)) {
							intersections.add(ixPointAsString);
							point.drawIntersection();

							// retrieve intersecting segments
							console.log("Segments: :", point.ids);
							var segment1 = linesMap.get(point.ids[0]);
							var segment2 = linesMap.get(point.ids[1]);

							// swap segment positions in the active tree
							active.swap(segment1, segment2);

							var upper, lower;
							if (segment1.ref.y < segment2.ref.y) {
								upper = segment1;
								lower = segment2
							} else {
								upper = segment2;
								lower = segment1
							}
							var upperNeighbor = active.previous(upper);
							ixUpperPoint = getIntersectionPoint(upper, upperNeighbor);
							if (ixUpperPoint) {
								console.log("Add intersection event: ", ixUpperPoint.ids);
								events.insert(ixUpperPoint);
							}
							ixCrossUpperPoint = getIntersectionPoint(upper, lowerNeighbor);
							if (ixCrossUpperPoint) {
								console.log("Remove intersection event: ", ixCrossUpperPoint.ids);
								events.remove(ixCrossUpperPoint);
							}
							var lowerNeighbor = active.next(lower);
							ixLowerPoint = getIntersectionPoint(lower, lowerNeighbor);
							if (ixLowerPoint) {
								console.log("Add intersection event: ", ixLowerPoint.ids);
								events.insert(ixLowerPoint);
							}
							ixCrossLowerPoint = getIntersectionPoint(lower, upperNeighbor);
							if (ixCrossLowerPoint) {
								console.log("Remove intersection: ", ixCrossLowerPoint.ids);
								events.remove(ixCrossLowerPoint);
							}

						}
					}
					events.remove(point);

					// sweep cursor line to the current point
					xCursor.transition().duration(1000)
						.attr("transform", function(){
							return "translate(" + point.x + ",0)";
						});

					if (events.size == 0) {
						clearInterval(intervalId);
						console.log("All intersections: ", intersections);
					}
				}
			}

			function printActiveTree(tree) {
				var printSet = [];
				tree.each(function(item) {
					printSet.push(item.id);
				});
				console.log("Active set: ", printSet);
			}

			function printEventsTree(tree) {
				var printSet = [];
				tree.each(function(item) {
					printSet.push(item);
				});
				console.log("Event set: ", printSet);
			}

			/* Initializes a new key-value map of lines and fills it with line data */ 
			function initLineMap(lines) {
				var map = new Map();
				lines.forEach(function(line, indx) {
					map.set(indx, new Segment(indx, { x:line[0][0], y:line[0][1] }, { x:line[1][0], y:line[1][1] }));
				});
				console.log("Lines Map: ", map);
				return map;
			}

			/*
				Initializes and returns an events/points tree data structure.
				Creates a new RB tree with events comparator.
				Inserts end points of known line segments into the tree.
				Points are sorted by X (key) coordinate.
			*/
			function initEventsTree(linesMap) {
				var events = new RBTree(function(a, b) { return a.x - b.x; });
				linesMap.forEach(function(value, key) {
					events.insert(new EventPoint("left", key, value.left.x, value.left.y));
					events.insert(new EventPoint("right", key, value.right.x, value.right.y));
				});
				console.log("Events: ", events);
				return events;
			}

			/* Checks upper & lower neighbor segments for intersections with the current (specified) segment */

			/*
				Intersection check.
				Returns an intersection point if lines intersect, or null otherwise.
			*/
			function getIntersectionPoint(segment1, segment2) {
				if (!segment1 || !segment2) {
					return null;
				}

				/* Derive coefficients for each line equation (ax + by = c), where a = y2 - y1, b = x1 - x2 */
				var x1 = segment1.left.x;
				var x2 = segment1.right.x;
				var y1 = segment1.left.y;
				var y2 = segment1.right.y;
				var a1 = y2 - y1;
				var b1 = x1 - x2;
				var c1 = a1*x1 + b1*y1;

				var x3 = segment2.left.x;
				var x4 = segment2.right.x;
				var y3 = segment2.left.y;
				var y4 = segment2.right.y;
				var a2 = y4 - y3;
				var b2 = x3 - x4;
				var c2 = a2*x3 + b2*y3;

				/*
					Find intersection point (x,y) by solving the system of linear equations
					using inverse matrix method:
					A*X = B => X = Ainv*B, where Ainv = [coeff. matrix]/det
					|a1 b1| * |x| = |c1| -> |x| =  1  * | b2 -b1| * |c1|
					|a2 b2|   |y|   |c2|    |y|   det   |-a2  a1|   |c2|
				*/
				var det = a1*b2 - a2*b1;
				if (det === 0) {	// lines are parallel
					console.log("Determinant = 0");
					return null;
				}

				// line intersection coordinates
				var x = (b2*c1 - b1*c2) / det;
				var y = (a1*c2 - a2*c1) / det;
				// console.log("Global intersection {x:", x, " y:", y, "} ids [", segment1.id, ",", segment2.id, "]");

				/* Segments intersect if (x,y) is within each segment's range */
				var point = new EventPoint("intersection", null, x, y);
				point.ids = [segment1.id, segment2.id];
				if (point.inRange(segment1.left, segment1.right) && point.inRange(segment2.left, segment2.right)) {
					console.log("In range intersection {x:", x.toFixed(2), " y:", y.toFixed(2), "}");
					return point;
				}

				console.log("Not in range: [", segment1.id, segment2.id, "]");
				return null;
			}

			/* Returns an array of terminal points for given lines. */
			function getPoints(lines) {
				var points = [];
				for (var i = 0; i < lines.length; i++) {
					for (var j = 0; j < lines[i].length; j++) {
						points.push(lines[i][j]);
					}
				}
				return points;
			}

			/*
				Maps lines to segment objects.
				Returns a collection of segments.
			*/
			function getSegments(lines) {
				return lines.map(function(val, indx) {
					return {
						id:  indx,
						left: { id: indx, type: "left", point: val[0] },
						right: { id: indx, type: "right", point: val[1] }
					};
				});
			}

			/*
				Maps lines to point objects.
				Sorts points in ascending order by x coordinate.
				Returns a collection of sorted segment points.
			*/
			function getSegmentPoints(lines) {
				var points = [];
				lines.forEach(function(val, idx) {
					points.push({ id: idx, type: "left", x: val[0][0], y: val[0][1] });
					points.push({ id: idx, type: "right", x: val[1][0], y: val[1][1] });
				});
				points.sort(function(a, b) {
					return a.x - b.x;
				});
				return points;
			}

			function drawRefPoint(point) {
				if (point) {
					svg.append("circle")
						.data([point])
						.style("fill",'green')
						.attr("r", 3)
						.attr("cx", function(d) { return d.x; })
						.attr("cy", function(d) { return d.y; });
				}
			}

		</script>
	</body>
</html>