<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Experiments with D3 shapes</title>
		<!-- <script type="text/javascript" src="libs/require.js"></script> -->
		<script type="text/javascript" src="libs/rbtree.min.js"></script>
		<script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>
		<style type="text/css">
			h1 {
				text-align: center;
				font-size: 20px;
			}
			svg {
				stroke-width: 3px;
				border: 1px solid grey;
			}
			.xAxis path, .xAxis line,
			.yAxis path, .yAxis line {
				fill: none;
				stroke: grey;
				stroke-width: 1;
				shape-rendering: crispEdges;
			}
			path.line {
				stroke: steelblue;
				stroke-width: 2;
				fill: steelblue;
				fill-opacity: 0.3;
			}
			path.xCursor {
				stroke: grey;
				stroke-width: 1;
			}
			circle {
				fill: blue;
			}
			path {
				stroke: steelblue;
				stroke-width: 2px;
				stroke-linecap: round;
			}
		</style>
	</head>
	<body>
	    <div id="graph">
			<h1>Line Sweep algorithm visualization</h1>
		</div>
		<div id="toolbox">
				<input id="undoBtn" name="updateButton"  type="button" value="Undo" onclick="removeLast()" />
				<input id="clearBtn" name="clearButton"  type="button" value="Clear" onclick="clearAll()" />
				<input id="sweepBtn" name="sweepButton"  type="button" value="Sweep" onclick="sweep()" />
		</div>
		<script type="text/javascript" charset="utf-8">

			var width = 600;
			var height = 400;

			var currentPath;
			var isDrawing = false;
			var lines = [];
			var intersections = [];

			/*
				Initializes main components and behavior.
			*/
			var svg = d3.select("body")
				.append("svg")
					.attr("width", width)
					.attr("height", height)
					.on("mousedown", onMouseDown)
					.on("mouseup", onMouseUp);

			/*
				Line function definition.
			*/
			var lineFunct = d3.line()
				.x(function (d) {
					return d[0];
				})
				.y(function (d) {
					return d[1];
				});

			/*
				OnMouseDown event handler.
				Captures mouse coordinates for the line's start point.
				Appends the line and its end point.
			*/
			function onMouseDown() {
				isDrawing = true;
				var startPos = d3.mouse(this);

				// set line's start point
				lines.push([startPos, [0, 0]]);
				console.log("start: ", startPos);

				// draw the line
				var line = lineFunct([startPos, startPos]);
				currentPath = svg.append("path").attr("d", line);

				// draw line's start point
				svg.append("circle")
					.data([startPos])
					.attr("r", 3)
					.attr("cx", function(d) {return d[0]; })
					.attr("cy", function(d) {return d[1]; });

				// pass arguments to onMouseMove
				svg.data([startPos])
					.on("mousemove", onMouseMove);
			}

			/*
				OnMouseMove event handler.
				Captures current mouse coordinates to visualize live drawing.
			*/
			function onMouseMove(startPos) {
				var currentPos = d3.mouse(this);
				if (isDrawing) {
					var line = lineFunct([startPos, currentPos]);
					currentPath.attr("d", line);
				}
			}

			/*
				OnMouseUp event handler.
				Captures mouse coordinates for the end of line being drawn.
				Updates and appends line's end point.
			*/
			function onMouseUp() {
				isDrawing = false;
				var startPos = lines[lines.length - 1][0];
				var endPos = d3.mouse(this);

				// update line's end points
				if (startPos[0] < endPos[0]) {
					lines[lines.length - 1][1] = endPos;
				} else {
					lines[lines.length - 1][0] = endPos;
					lines[lines.length - 1][1] = startPos;
				}

				// draw line's end point
				svg.append("circle")
					.data([endPos])
					.attr("r", 3)
					.attr("cx", function(d) {return d[0]; })
					.attr("cy", function(d) {return d[1]; });
				console.log("lines: ", lines.toString());
			}

			/*
				Removes the last line and associated terminal points
				1. associate data to selection
				2. retrieve and remove the diff
			*/
			function removeLast() {
				console.log("Removed line: ", lines.pop());
				svg.selectAll("path").data(lines).exit().remove();
				svg.selectAll("circle").data(getPoints(lines)).exit().remove();
			}

			/*
				Cleans the drawing area.
				Removes all lines and associated terminal points.
			*/
			function clearAll() {
				console.log("Clearing ...")
				svg.selectAll("path").remove();
				svg.selectAll("circle").remove();
			}

			/*
				Sweeps the cursor through data all points.
				Smoothly translates the line by x pixels b/w points.
			*/
			function sweep() {
				// build key-value map of lines
				var linesMap = new Map();
				lines.forEach(function(line, indx) {
					linesMap.set(indx, { id:indx, left:{ x:line[0][0], y:line[0][1] }, right:{ x:line[1][0], y:line[1][1] } });
				});
				console.log("Lines Map: ", linesMap);

			/* 1. Init intersection point holder. */
				var intersections = new Set();

			/* 2. Init an empty active set that holds segments currently crossed by the sweep line. */

				// contains segments cut by SL and sorted by Y (left point)
				var active = new RBTree(function(a, b) {
					return a.left.y - b.left.y;
				});
				console.log("Active: ", active);

			/* 3. Init a priority queue (BST) and fill it with all segment's end-points sorted by X coordinate. */

				// segment's end-points and intersection points sorted by X (unique key)
				var events = new RBTree(function(a, b) { return a.x - b.x; });
				linesMap.forEach(function(value, key) {
					events.insert({ type:"left", x:value.left.x, y:value.left.y, lineId:key });
					events.insert({ type:"right", x:value.right.x, y:value.right.y, lineId:key });
				});
				console.log("Events: ", events);

				// get X values for all points
				var xVals = getPoints(lines).map(function(d) { return d[0]; });
				xVals.sort(d3.descending);

				var x = 0;
				var xCursor = svg.append("path")
					.attr("d", lineFunct([[x, 0], [x, height]]))
					.attr('class', 'xCursor');

				var id = setInterval(frame, 1000);
				function frame() {
					var point = events.min();
					events.remove(point);
					console.log("Min Point: ", point);

					var segment = linesMap.get(point.lineId);
					if (isLeft(point)) {
						console.log("Insert segment: ", segment);
						active.insert(segment);
					} else {
						console.log("Remove segment: ", segment);
						active.remove(segment);
					}
					console.log("Active: ", active);

					x = xVals.pop();
					console.log("xCursor: ", x);
					xCursor.transition().duration(1000)
						.attr("transform", function(){
							return "translate(" + x + ",0)";
						});
					// detect line intersections
					// add intersection points and report their coordinates

					if (xVals.length == 0) {
						clearInterval(id);
					}
				}
				// ------------------------------------------------------------------------------------
/*
				var segmentPoints = getSegmentPoints(lines);
				console.log("Segment points: ", JSON.stringify(segmentPoints));

				var segments = getSegments(lines);
				console.log("Segments: ", JSON.stringify(segments));

				// get X values for all points
				var xVals = getPoints(lines).map(function(d) { return d[0]; });
				xVals.sort(d3.descending);

				var x = 0;
				var xCursor = svg.append("path")
					.attr("d", lineFunct([[x, 0], [x, height]]))
					.attr('class', 'xCursor');

				var id = setInterval(frame, 1000);
				function frame() {
					x = xVals.pop();
					console.log("xCursor: ", x);
					xCursor.transition().duration(1000)
						.attr("transform", function(){
							return "translate(" + x + ",0)";
						});
					// detect line intersections
					// add intersection points and report their coordinates

					if (xVals.length == 0) {
						clearInterval(id);
					}
				}
*/
				/*
					0. Init intersection point holder.
					1. Init an empty active set that holds segments currently crossed by the sweep line 
					2. Init a priority queue (BST) and fill it with all segment's end-points sorted by X coordinate
					3. While the BST is not empty, process each end-point:
						3.1 Retrieve the point with min X coordinate
						3.2 If it's a "left" endpoint
							- insert the line the point belongs to into an active set sorted by left point's Y coordinate
							- check neighbors, if any, for intersections
							- ??? insert discovered intersection, if any, into the priority queue (BST)
							- insert discovered intersection, if any, into the ordered set of intersections
						3.3 If it's a "right" point
							- remove the line the point belongs to from the active set
							- check neighbors, if any, for intersections
							- insert discovered intersections, into "found" set 
				*/


				return intersections;
			}

			/*
				Initilizes events tree data structure.
				Creates new RB tree with corresponding comparator.
				Inserts end points of known line segments into the tree.
				Points are sorted by X coordinate.
			*/
			function initEventsTree() {
				var eventsTree = new RBTree(function(a, b) { return a.x - b.x; });
				// insert end points
				console.log("Events: ", eventsTree);
				return eventsTree;
			}

			/*
				Intersection check.
				Returns true if lines intersect, or false otherwise.
			*/
			function doIntersect(segment1, segment2) {
				/*
					Derive coefficients for each line equation (ax + by = c),
					where a = y2 - y1, b = x1 - x2
				*/
				var x1 = segment1.left.point[0];
				var x2 = segment1.right.point[0];
				var y1 = segment1.left.point[1];
				var y2 = segment1.right.point[1];
				var a1 = y2 - y1;
				var b1 = x1 - x2;
				var c1 = a1*x1 + b1*y1;

				var x3 = segment2.left.point[0];
				var y3 = segment2.left.point[1];
				var x4 = segment2.right.point[0];
				var y5 = segment2.right.point[1];
				var a2 = y4 - y3;
				var b2 = x3 - x4;
				var c2 = a2*x3 + b2*y3;

				/*
					Find intersection point (x,y) by solving the system of linear equations
					using inverse matrix method:
					A*X = B => X = Ainv*B, where Ainv = [coeff. matrix]/det
					|a1 b1| * |x| = |c1| -> |x| =  1  * | b2 -b1| * |c1|
					|a2 b2|   |y|   |c2|    |y|   det   |-a2  a1|   |c2|
				*/
				var det = a1*b2 - a2*b1;
				if (det === 0) {	// lines are parallel
					return false;
				}

				// line intersection coordinates
				var x = (b2*c1 - b1*c2) / det;
				var y = (a1*c2 - a2*c1) / det;

				/* Segments intersect if (x,y) is within the segment's range */
				return x > min(x1, x2) && x < max(x3, x4) && y > min(y1, y2) && y < max(y3, y4);
			}

			/*
				Returns an array of terminal points for given lines.
			*/
			function getPoints(lines) {
				var points = [];
				for (var i = 0; i < lines.length; i++) {
					for (var j = 0; j < lines[i].length; j++) {
						points.push(lines[i][j]);
					}
				}
				return points;
			}

			/*
				Maps lines to segment objects.
				Returns a collection of segments.
			*/
			function getSegments(lines) {
				return lines.map(function(val, indx) {
					return {
						id:  indx,
						left: { id: indx, type: "left", point: val[0] },
						right: { id: indx, type: "right", point: val[1] }
					};
				});
			}

			/*
				Maps lines to point objects.
				Sorts points in ascending order by x coordinate.
				Returns a collection of sorted segment points.
			*/
			function getSegmentPoints(lines) {
				var points = [];
				lines.forEach(function(val, idx) {
					points.push({ id: idx, type: "left", x: val[0][0], y: val[0][1] });
					points.push({ id: idx, type: "right", x: val[1][0], y: val[1][1] });
				});
				points.sort(function(a, b) {
					return a.x - b.x;
				});
				return points;
			}

			function isLeft(point) {
				return point.type === "left";
			}

			function isRight(point) {
				return point.type === "right";
			}

			function max(val1, val2) {
				return val1 > val2 ? val1 : val2;
			}

			function min(val1, val2) {
				return val1 < val2 ? val1 : val2;
			}
/*			svg.on('mousedown', function() {
					isDrawing = true;
					startPos = d3.mouse(this);
					console.log("start: ", startPos);

					var line = lineFunct([startPos, startPos]);
					path = svg.append("path").attr("d", line);
				})
				.on('mousemove', function() {
					var endPos = d3.mouse(this).map(function(x){ return x - 1; });
					if (isDrawing) {
						var line = lineFunct([startPos, endPos]);
						path.attr("d", line);
					}
				})
				.on('mouseup', function() {
					isDrawing = false;
					console.log("end: ", d3.mouse(this));
				});*/

/*			var labelDistance = 0;
			var width = 600, height = 400;
			var margin = { top: 20, right: 80, bottom: 30, left: 50 };

			var x = d3.scaleLinear().range([0, width]).domain([0,200]);
			var y = d3.scaleLinear().range([height, 0]).domain([0,400]);

			var xAxis = d3.axisBottom().scale(x).ticks(5);
			var yAxis = d3.axisLeft().scale(y).ticks(5);

			var svg = d3.select("body")
				.append("svg")
					.on("mousedown", mousedown)
					.on("mouseup", mouseup)
					.attr("width", width + margin.left + margin.right)
					.attr("height", height + margin.top + margin.bottom)
				.append("g")
					.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			svg.append("g")
				.attr("class", "xAxis")
				.attr("transform", "translate(0," + height + ")")
				.call(xAxis);
			svg.append("g")
				.attr("class", "yAxis")
				.call(yAxis);
*/
			/* Add and configure lines */
/*			
			var lineFunct = d3.line()
				.x(function (d) { return x(d[0]); })
				.y(function (d) { return y(d[1]); });

			var drawLines = function(lines) {
				for (var i = 0; i < lines.length; i++) {
					svg.append("path")
						.datum(lines[i])
						.attr("class", "line")
						.attr("d", lineFunct);
				}
			}

			var linesToPoints = function(lines) {
				var points = [];
				for (var i = 0; i < lines.length; i++) {
					for (var j = 0; j < lines[i].length; j++) {
						points.push(lines[i][j]);
					}
				}
				return points;
			}*/

			/* Prepare data */
/*			var lines = [
			  [[ 20, 20 ], [ 70, 40 ]],
			  [[ 40, 40 ], [ 60, 70 ]],
			  [[ 80, 20 ], [ 80, 60 ]]
			]
			drawLines(lines);*/

			/* Add and configure line points */
/*			var points = linesToPoints(lines);
			svg.selectAll("point.circle")
				.data(points)
				.enter()
				.append("circle")
				.attr("class", 'point')
				.attr("r", 3)
				.attr("cx", function(d) { return x(d[0]); })
				.attr("cy", function(d) { return y(d[1]); });

			var newline;
			var draw = false;
			function mousedown() {
				draw = true;
				var startPos = d3.mouse(this);
				console.log("down: ", startPos);
				svg.append("path")
					// .datum(newline)
					.attr("class", "line")
					.attr("d", lineFunct([startPos, startPos]));
				svg.on("mousemove", mousemove);
			}

			function mouseup() {
				var endPos = d3.mouse(this);
				console.log("up: ", endPos);
				// svg.on("mousemove", null);
				draw = false;
			}

			function mousemove() {
				var currentPos = d3.mouse(this);
				console.log("move: ", currentPos);
				if (draw) {
					var path = currentPos.map(function(x) { return x - 1; });
					svg.attr("d", path);
				}
			}*/

		</script>
	</body>
</html>