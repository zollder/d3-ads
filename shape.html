<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Experiments with D3 shapes</title>
		<!-- <script type="text/javascript" src="libs/require.js"></script> -->
		<script type="text/javascript" src="libs/rbtree.min.js"></script>
		<script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>
		<style type="text/css">
			h1 {
				text-align: center;
				font-size: 20px;
			}
			svg {
				stroke-width: 3px;
				border: 1px solid grey;
			}
			.xAxis path, .xAxis line,
			.yAxis path, .yAxis line {
				fill: none;
				stroke: grey;
				stroke-width: 1;
				shape-rendering: crispEdges;
			}
			path.line {
				stroke: steelblue;
				stroke-width: 2;
				fill: steelblue;
				fill-opacity: 0.3;
			}
			path.xCursor {
				stroke: grey;
				stroke-width: 1;
			}
			circle {
				fill: blue;
			}
			path {
				stroke: steelblue;
				stroke-width: 2px;
				stroke-linecap: round;
			}
		</style>
	</head>
	<body>
	    <div id="graph">
			<h1>Line Sweep algorithm visualization</h1>
		</div>
		<div id="toolbox">
				<input id="undoBtn" name="updateButton"  type="button" value="Undo" onclick="removeLast()" />
				<input id="clearBtn" name="clearButton"  type="button" value="Clear" onclick="clearAll()" />
				<input id="sweepBtn" name="sweepButton"  type="button" value="Sweep" onclick="sweep()" />
		</div>
		<script type="text/javascript" charset="utf-8">

		/* TODO:
			1. convert lines array of arrays to an array of objects to be able to add labels and so other useful manipulations
			2. round inersection point values and show its coordinates
			3. 
		*/

			var width = 600;
			var height = 400;

			var currentPath;
			var isDrawing = false;
			var lines = [];
			var intersections = [];

			/*
				Initializes main components and behavior.
			*/
			var svg = d3.select("body")
				.append("svg")
					.attr("width", width)
					.attr("height", height)
					.on("mousedown", onMouseDown)
					.on("mouseup", onMouseUp);

			/*
				Line function definition.
			*/
			var lineFunct = d3.line()
				.x(function (d) {
					return d[0];
				})
				.y(function (d) {
					return d[1];
				});

			/*
				OnMouseDown event handler.
				Captures mouse coordinates for the line's start point.
				Appends the line and its end point.
			*/
			function onMouseDown() {
				isDrawing = true;
				var startPos = d3.mouse(this);

				// set line's start point
				lines.push([startPos, [0, 0]]);
				console.log("start: ", startPos);

				// draw the line
				var line = lineFunct([startPos, startPos]);
				currentPath = svg.append("path").attr("d", line);

				// draw line's start point
				svg.append("circle")
					.data([startPos])
					.attr("r", 3)
					.attr("cx", function(d) {return d[0]; })
					.attr("cy", function(d) {return d[1]; });

				// pass arguments to onMouseMove
				svg.data([startPos])
					.on("mousemove", onMouseMove);
			}

			/*
				OnMouseMove event handler.
				Captures current mouse coordinates to visualize live drawing.
			*/
			function onMouseMove(startPos) {
				var currentPos = d3.mouse(this);
				if (isDrawing) {
					var line = lineFunct([startPos, currentPos]);
					currentPath.attr("d", line);
				}
			}

			/*
				OnMouseUp event handler.
				Captures mouse coordinates for the end of line being drawn.
				Updates and appends line's end point.
			*/
			function onMouseUp() {
				isDrawing = false;
				var startPos = lines[lines.length - 1][0];
				var endPos = d3.mouse(this);

				// update line's end points
				if (startPos[0] < endPos[0]) {
					lines[lines.length - 1][1] = endPos;
				} else {
					lines[lines.length - 1][0] = endPos;
					lines[lines.length - 1][1] = startPos;
				}

				// draw line's end point
				svg.append("circle")
					.data([endPos])
					.attr("r", 3)
					.attr("cx", function(d) {return d[0]; })
					.attr("cy", function(d) {return d[1]; });
				console.log("lines: ", lines.toString());
			}

			/*
				Removes the last line and associated terminal points
				1. associate data to selection
				2. retrieve and remove the diff
			*/
			function removeLast() {
				console.log("Removed line: ", lines.pop());
				svg.selectAll("path").data(lines).exit().remove();
				svg.selectAll("circle").data(getPoints(lines)).exit().remove();
			}

			/*
				Cleans the drawing area.
				Removes all lines and associated terminal points.
			*/
			function clearAll() {
				console.log("Clearing ...")
				svg.selectAll("path").remove();
				svg.selectAll("circle").remove();
			}

			// ------------------------------------------------------------------------------------
			/*
				0. Init intersection point holder.
				1. Init an empty active set that holds segments currently crossed by the sweep line 
				2. Init a priority queue (BST) and fill it with all segment's end-points sorted by X coordinate
				3. While the BST is not empty, process each end-point:
					3.1 Retrieve the point with min X coordinate
					3.2 If it's a "left" endpoint
						- insert the line the point belongs to into an active set sorted by left point's Y coordinate
						- check neighbors, if any, for intersections
						- ??? insert discovered intersection, if any, into the priority queue (BST)
						- insert discovered intersection, if any, into the ordered set of intersections
					3.3 If it's a "right" point
						- remove the line the point belongs to from the active set
						- check neighbors, if any, for intersections
						- insert discovered intersections, into "found" set 
			*/

			var EventPoint = {
				type: null,
				x: null,
				y: null,
				lineId: null,

				isLeft: function(point) {
					return point.type === "left";
				},

				isRight: function(point) {
					return point.type === "right";
				},

				isIntersection: function(point) {
					return point.type === "intersection";
				}
			};

			var LineSegment = {

			};

			var BTree = {

			}

			/*
				Sweeps the cursor through data all points.
				Smoothly translates the line by x pixels b/w points.
			*/
			function sweep() {
				var linesMap = initLineMap(lines);
				var intersections = new Set();

				// contains segments cut by SL and sorted by Y (left point)
				// TODO: add support for positions and element swaps
				var active = new RBTree(function(a, b) {
					return a.ref.y - b.ref.y;
				});

				// segment's end-points and intersection points sorted by X (unique key)
				var events = initEventsTree(linesMap);

				// initialize the cursor
				var xCursor = svg.append("path")
					.attr("d", lineFunct([[0, 0], [0, height]]))
					.attr('class', 'xCursor');

				// loop through all events/points
				var intervalId = setInterval(frame, 1000);
				function frame() {
					printEventsTree(events);

					var point = events.min();
					var segment = linesMap.get(point.lineId);

					if (isLeft(point)) {
						console.log("Insert segment: ", segment.id);
						drawLineLable(point);
						active.insert(segment); // TODO: add logic to manage ref point duplicates

						var ixUpperPoint = getIntersectionPoint(segment, getPrevious(active, segment));
						if (ixUpperPoint) {
							console.log("Add intersection event: ", ixUpperPoint);
							events.insert(ixUpperPoint);
						}
						var ixLowerPoint = getIntersectionPoint(segment, getNext(active, segment));
						if (ixLowerPoint) {
							console.log("Add intersection event: ", ixLowerPoint);
							events.insert(ixLowerPoint);
						}
						var ixPoint = getIntersectionPoint(getNext(active, segment), getPrevious(active, segment));
						if (ixPoint) {
							console.log("Remove intersection event: ", ixPoint);
							events.remove(ixPoint);
						}
					}
					else if (isRight(point)) {
						printActiveTree(active);

						var ixPoint = getIntersectionPoint(getPrevious(active, segment), getNext(active, segment));
						if (ixPoint) {
							events.insert(ixPoint);
						}
						console.log("Remove from active: ", segment.id);
						active.remove(segment);
					}
					else {	// intersection point
						// add this point to intersections set/list
						console.log("Processing intersection point:", point);
						intersections.add(JSON.stringify({ x:point.x, y:point.y }));
						drawIntersectionPoint(point);

						// retrieve intersecting segments
						console.log("Segments: :", point.ids);
						var segment1 = linesMap.get(point.ids[0]);
						var segment2 = linesMap.get(point.ids[1]);

						// swap segment positions in the active tree
						printActiveTree(active);
						if (active.remove(segment1) &&  active.remove(segment2)) {
							var xRef = point.x + 0.001;
							active.insert(updateRefPoint(xRef, segment1));
							active.insert(updateRefPoint(xRef, segment2));
							printActiveTree(active);

							var upper, lower;
							if (segment1.ref.y < segment2.ref.y) {
								upper = segment1;
								lower = segment2
							} else {
								upper = segment2;
								lower = segment1
							}
							var upperNeighbor = getPrevious(active, upper);
							ixUpperPoint = getIntersectionPoint(upper, upperNeighbor);
							if (ixUpperPoint) {
								events.insert(ixUpperPoint);
							}
							ixCrossUpperPoint = getIntersectionPoint(upper, lowerNeighbor);
							if (ixCrossUpperPoint) {
								events.remove(ixCrossUpperPoint);
							}
							var lowerNeighbor = getNext(active, lower);
							ixLowerPoint = getIntersectionPoint(lower, lowerNeighbor);
							if (ixLowerPoint) {
								events.insert(ixLowerPoint);
							}
							ixCrossLowerPoint = getIntersectionPoint(lower, upperNeighbor);
							if (ixCrossLowerPoint) {
								events.remove(ixCrossLowerPoint);
							}
						} else {
							console.log("Failed to swap segments: ", upper, lower);
						}
					}
					events.remove(point);

					// sweep cursor line to the current point
					xCursor.transition().duration(1000)
						.attr("transform", function(){
							return "translate(" + point.x + ",0)";
						});

					if (events.size == 0) {
						clearInterval(intervalId);
						console.log("All intersections: ", intersections);
					}
				}
			}

			function getPrevious(tree, item) {
				if (!tree || ! item) {
					return null;
				}
				var iter = tree.findIter(item);
				if (iter && iter.prev()) {
					return iter.data();
				}
				return null;
			}

			function getNext(tree, item) {
				if (!tree || ! item) {
					return null;
				}
				var iter = tree.findIter(item);
				if (iter && iter.next()) {
					return iter.data();
				}
				return null;
			}

			function printActiveTree(tree) {
				var printSet = [];
				tree.each(function(item) {
					printSet.push(item.id);
				});
				console.log("Active set: ", printSet);
			}

			// TODO: temp function, remove when done
			function getPrintSet(tree) {
				var printSet = [];
				tree.each(function(item) {
					printSet.push(item.id);
				});
				return printSet;
			}

			function printEventsTree(tree) {
				var printSet = [];
				tree.each(function(item) {
					printSet.push(item);
				});
				console.log("Event set: ", printSet);
			}

			/* Initializes a new key-value map of lines and fills it with line data */ 
			function initLineMap(lines) {
				var map = new Map();
				lines.forEach(function(line, indx) {
					map.set(indx, {
						id:indx,
						ref:{ x:line[0][0], y:line[0][1] },
						left:{ x:line[0][0], y:line[0][1] },
						right:{ x:line[1][0], y:line[1][1] }
					});
				});
				console.log("Lines Map: ", map);
				return map;
			}

			/*
				Initilizes and returns an events/points tree data structure.
				Creates a new RB tree with events comparator.
				Inserts end points of known line segments into the tree.
				Points are sorted by X (key) coordinate.
			*/
			function initEventsTree(linesMap) {
				var events = new RBTree(function(a, b) { return a.x - b.x; });
				linesMap.forEach(function(value, key) {
					events.insert({ type:"left", x:value.left.x, y:value.left.y, lineId:key });
					events.insert({ type:"right", x:value.right.x, y:value.right.y, lineId:key });
				});
				console.log("Events: ", events);
				return events;
			}

			/* Checks upper & lower neighbor segments for intersections with the current (specified) segment */

			/*
				Intersection check.
				Returns an intersection point if lines intersect, or null otherwise.
			*/
			function getIntersectionPoint(segment1, segment2) {
				if (!segment1 || !segment2) {
					return null;
				}

				/* Derive coefficients for each line equation (ax + by = c), where a = y2 - y1, b = x1 - x2 */
				var x1 = segment1.left.x;
				var x2 = segment1.right.x;
				var y1 = segment1.left.y;
				var y2 = segment1.right.y;
				var a1 = y2 - y1;
				var b1 = x1 - x2;
				var c1 = a1*x1 + b1*y1;

				var x3 = segment2.left.x;
				var x4 = segment2.right.x;
				var y3 = segment2.left.y;
				var y4 = segment2.right.y;
				var a2 = y4 - y3;
				var b2 = x3 - x4;
				var c2 = a2*x3 + b2*y3;

				/*
					Find intersection point (x,y) by solving the system of linear equations
					using inverse matrix method:
					A*X = B => X = Ainv*B, where Ainv = [coeff. matrix]/det
					|a1 b1| * |x| = |c1| -> |x| =  1  * | b2 -b1| * |c1|
					|a2 b2|   |y|   |c2|    |y|   det   |-a2  a1|   |c2|
				*/
				var det = a1*b2 - a2*b1;
				if (det === 0) {	// lines are parallel
					console.log("Determinant = 0");
					return null;
				}

				// line intersection coordinates
				var x = (b2*c1 - b1*c2) / det;
				var y = (a1*c2 - a2*c1) / det;
				// console.log("Global intersection {x:", x, " y:", y, "} ids [", segment1.id, ",", segment2.id, "]");

				/* Segments intersect if (x,y) is within each segment's range */
				var point = { type:"intersection", x:x, y:y, ids:[segment1.id, segment2.id] };
				if (inRange(point, segment1) && inRange(point, segment2)) {
					console.log("In range intersection {x:", x.toFixed(2), " y:", y.toFixed(2), "}");
					return point;
				}

				console.log("Not in range");
				return null;
			}

			function updateRefPoint(xRef, segment) {
				var x1 = segment.left.x;
				var x2 = segment.right.x;
				var y1 = segment.left.y;
				var y2 = segment.right.y;
				var A = y2 - y1;
				var B = x1 - x2;
				var C = A*x1 + B*y1;
				// Ax + By = C => y = (C - Ax) / B
				segment.ref.x = xRef;
				segment.ref.y = (C - A*xRef)/B;
				return segment;
			}

			function getUpdatedRefPoint(xRef, segment) {
				var x1 = segment.left.x;
				var x2 = segment.right.x;
				var y1 = segment.left.y;
				var y2 = segment.right.y;
				var A = y2 - y1;
				var B = x1 - x2;
				var C = A*x1 + B*y1;
				// Ax + By = C => y = (C - Ax) / B
				var yRef = (C - A*xRef)/B;
				return {x:xRef, y:yRef};
			}

			/* Returns an array of terminal points for given lines. */
			function getPoints(lines) {
				var points = [];
				for (var i = 0; i < lines.length; i++) {
					for (var j = 0; j < lines[i].length; j++) {
						points.push(lines[i][j]);
					}
				}
				return points;
			}

			/*
				Maps lines to segment objects.
				Returns a collection of segments.
			*/
			function getSegments(lines) {
				return lines.map(function(val, indx) {
					return {
						id:  indx,
						left: { id: indx, type: "left", point: val[0] },
						right: { id: indx, type: "right", point: val[1] }
					};
				});
			}

			/*
				Maps lines to point objects.
				Sorts points in ascending order by x coordinate.
				Returns a collection of sorted segment points.
			*/
			function getSegmentPoints(lines) {
				var points = [];
				lines.forEach(function(val, idx) {
					points.push({ id: idx, type: "left", x: val[0][0], y: val[0][1] });
					points.push({ id: idx, type: "right", x: val[1][0], y: val[1][1] });
				});
				points.sort(function(a, b) {
					return a.x - b.x;
				});
				return points;
			}

			/* Draws specified intersection point */
			function drawIntersectionPoint(point) {
				if (point) {
					svg.append("circle")
						.data([point])
						.style("fill",'red')
						.attr("r", 3)
						.attr("cx", function(d) { return d.x; })
						.attr("cy", function(d) { return d.y; });
				}
			}

			function drawRefPoint(point) {
				if (point) {
					svg.append("circle")
						.data([point])
						.style("fill",'green')
						.attr("r", 3)
						.attr("cx", function(d) { return d.x; })
						.attr("cy", function(d) { return d.y; });
				}
			}

			function drawLineLable(point) {
				if (point) {
					svg.append("text")
						.data([point])
						.attr("x", function(d) { return d.x; })
						.attr("y", function(d) { return d.y; })
						.attr("dx", "-10")
						.attr("dy", "-5")
						.text(function(d) { return d.lineId; });
				}
			}

			function isLeft(point) {
				return point.type === "left";
			}

			function isRight(point) {
				return point.type === "right";
			}

			function isIntersection(point) {
				return point.type === "intersection";
			}

			/*
				Verifies if the point is in range of the segment.
				Returns true if the point lies within segment's projections, or false otherwise.
			*/
			function inRange(point, segment) {
				return point.x >= min(segment.left.x, segment.right.x)
					&& point.y >= min(segment.left.y, segment.right.y)
					&& point.x <= max(segment.left.x, segment.right.x)
					&& point.y <= max(segment.left.y, segment.right.y);
			}

			function min(val1, val2) {
				return val1 < val2 ? val1 : val2;
			}

			function max(val1, val2) {
				return val1 > val2 ? val1 : val2;
			}

		</script>
	</body>
</html>